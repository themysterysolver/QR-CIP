import numpy as np
import matplotlib.pyplot as plt
import cv2
import qrcode
from PIL import Image

# Define PSNR and NCORR functions
def psnr(original, reconstructed):
    mse = np.mean((original - reconstructed) ** 2)
    if mse == 0:
        return float('inf')
    max_pixel = 255.0
    return 20 * np.log10(max_pixel / np.sqrt(mse))

def normxcorr2D(original, reconstructed):
    corr = np.corrcoef(original.flatten(), reconstructed.flatten())
    return corr[0, 1]

# Permutation Scrambling Functions
def lss_permutation(seed, n, r=3.9, s=3.0):
    """
    Generate a valid and chaotic permutation sequence using LSS.
    :param seed: Initial seed value (x0) for the LSS algorithm.
    :param n: Length of the permutation sequence.
    :param r: Control parameter for the logistic map (default: 3.9).
    :param s: Control parameter for the sine map (default: 3.0).
    :return: A list of permuted indices.
    """
    x = seed  # Initial seed
    sequence = [(x := (r * x * (1 - x) + s * np.sin(np.pi * x)) % 1, i) for i in range(n)]
    permuted_indices = [i for _, i in sorted(sequence, reverse=True)]
    return np.array(permuted_indices)

def crop_qr_border(img):
    """
    Crop the white border around the QR code.
    :param img: Input image.
    :return: Cropped image.
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return img  # If no contours found, return the original image
    cnt = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(cnt)
    margin = 5
    x = max(0, x - margin)
    y = max(0, y - margin)
    w = min(img.shape[1] - x, w + 2 * margin)
    h = min(img.shape[0] - y, h + 2 * margin)
    return img[y:y+h, x:x+w]

def divide_qr(img):
    """
    Divide image into 4x4 grid of 16 blocks.
    :param img: Input image (QR code).
    :return: A list of 16 smaller blocks.
    """
    if img.shape[0] % 4 != 0 or img.shape[1] % 4 != 0:
        img = cv2.resize(img, (400, 400))  # Resize to ensure divisibility by 4
    block_size = img.shape[0] // 4
    return np.array([
        img[i * block_size:(i + 1) * block_size, j * block_size:(j + 1) * block_size]
        for i in range(4) for j in range(4)
    ])

def scramble_qr(blocks, permutation):
    """
    Scramble QR code blocks.
    :param blocks: List of divided blocks.
    :param permutation: Permutation sequence.
    :return: Scrambled blocks.
    """
    return blocks[permutation.tolist()]

def descramble_qr(blocks, permutation):
    """
    Reverse scrambling using inverse permutation.
    :param blocks: Scrambled blocks.
    :param permutation: Permutation sequence.
    :return: Descrambled blocks.
    """
    inverse_perm = np.argsort(permutation)
    return blocks[inverse_perm.tolist()]

def rebuild_matrix(blocks):
    """
    Reconstruct image from 4x4 blocks.
    :param blocks: List of blocks.
    :return: Reconstructed image.
    """
    return np.vstack([np.hstack(blocks[i * 4:(i + 1) * 4]) for i in range(4)])

# XOR Diffusion Functions
def encrypt(input_image, share_size):
    """
    Encrypt the input image using XOR diffusion.
    :param input_image: Input image (2D numpy array).
    :param share_size: Number of shares to generate.
    :return: Shares and the original image.
    """
    image = np.asarray(input_image)
    if len(image.shape) == 3:  # If the image has 3 channels (RGB), convert to grayscale
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    (row, column) = image.shape
    shares = np.random.randint(0, 256, size=(row, column, share_size), dtype=np.uint8)
    shares[:, :, -1] = image.copy()
    for i in range(share_size - 1):
        shares[:, :, -1] = shares[:, :, -1] ^ shares[:, :, i]
    return shares, image

def decrypt(shares):
    """
    Decrypt the shares to reconstruct the original image.
    :param shares: Shares generated by the encryption function.
    :return: Reconstructed image and its numpy array.
    """
    (row, column, share_size) = shares.shape
    shares_image = shares.copy()
    for i in range(share_size - 1):
        shares_image[:, :, -1] = shares_image[:, :, -1] ^ shares_image[:, :, i]
    final_output = shares_image[:, :, share_size - 1]
    output_image = Image.fromarray(final_output.astype(np.uint8))
    return output_image, final_output

# Display Functions
def display_images(qr_image, shares, reconstructed_image, title_prefix=""):
    """
    Display the QR code, shares, and reconstructed image.
    :param qr_image: QR code image.
    :param shares: List of shares.
    :param reconstructed_image: Reconstructed image.
    :param title_prefix: Prefix for the titles of the displayed images.
    """
    plt.figure(figsize=(5, 5))
    plt.imshow(qr_image, cmap='gray')
    plt.title(f"{title_prefix} QR Code")
    plt.axis('off')
    plt.show()

    fig, axes = plt.subplots(1, len(shares), figsize=(15, 5))
    for i, share in enumerate(shares):
        axes[i].imshow(share, cmap='gray')
        axes[i].set_title(f'{title_prefix} Share {i + 1}')
        axes[i].axis('off')
    plt.show()

    plt.figure(figsize=(5, 5))
    plt.imshow(reconstructed_image, cmap='gray')
    plt.title(f"{title_prefix} Reconstructed Image")
    plt.axis('off')
    plt.show()

# Main Program
if __name__ == "__main__":
    # Ask the user for a string input
    user_input = input("Enter a string to generate a QR code: ")

    # Generate QR Code
    qr = qrcode.make(user_input)
    qr.save("qr.png")

    # Load and preprocess the QR code image
    img = cv2.imread("qr.png")
    img = crop_qr_border(img)
    img = cv2.resize(img, (400, 400))  # Ensure the image is 400x400

    # Divide the QR code into 4x4 blocks
    divided_blocks = divide_qr(img)

    # Generate permutation sequence
    seed = 0.85  # Change seed for more randomization
    n = 16  # Number of blocks (4x4 grid)
    permutation = lss_permutation(seed, n)
    print("Permutation Sequence:", permutation)

    # Scramble the blocks
    scrambled_blocks = scramble_qr(divided_blocks, permutation)
    scrambled_qr = rebuild_matrix(scrambled_blocks)

    # Display the scrambled QR code
    print("Scrambled QR Code:")
    plt.imshow(scrambled_qr, cmap='gray')
    plt.title("Scrambled QR Code")
    plt.axis('off')
    plt.show()

    # Apply XOR diffusion to the scrambled QR code
    try:
        share_size = int(input("Input the number of shares images you want to create for encrypting (min is 2, max is 8): "))
        if share_size < 2 or share_size > 8:
            raise ValueError
    except ValueError:
        print("Input is not a valid integer!")
        exit(0)

    # Encrypt the scrambled QR code
    shares, scrambled_matrix = encrypt(scrambled_qr, share_size)

    # Decrypt the shares to reconstruct the scrambled QR code
    output_image, output_matrix = decrypt(shares)

    # Display the shares and reconstructed scrambled QR code
    print("Shares and Reconstructed Scrambled QR Code:")
    display_images(scrambled_qr, [shares[:, :, i] for i in range(share_size)], output_matrix, "Scrambled")

    # Descramble the reconstructed QR code
    descrambled_blocks = descramble_qr(divide_qr(output_matrix), permutation)
    descrambled_qr = rebuild_matrix(descrambled_blocks)

    # Display the final descrambled QR code
    print("Descrambled QR Code:")
    plt.imshow(descrambled_qr, cmap='gray')
    plt.title("Descrambled QR Code")
    plt.axis('off')
    plt.show()

    # Evaluation metrics
    # Evaluation metrics
    original_qr = np.asarray(Image.open("qr.png").convert('L'))

# Resize the descrambled QR code to match the original QR code dimensions
    descrambled_qr_resized = cv2.resize(descrambled_qr, (original_qr.shape[1], original_qr.shape[0]))

    print("Evaluation metrics:")
    print(f"PSNR value is {psnr(original_qr, descrambled_qr_resized)} dB")
    print(f"Mean NCORR value is {normxcorr2D(original_qr, descrambled_qr_resized)}")
